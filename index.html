<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Illuminarchism | The Living Atlas</title>
    
    <!-- Google Fonts for Medieval Aesthetic -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Palette: Medieval Manuscript */
            --parchment-bg: #f3e9d2;
            --parchment-dark: #e0d0b0;
            --ink-primary: #2b2118;
            --ink-faded: #5c4d3c;
            --rubric-red: #8a3324;
            --gold-leaf: #c5a059;
            --lapis-lazuli: #264e86;
            
            --ui-shadow: 0 4px 6px rgba(43, 33, 24, 0.2);
            --border-width: 2px;
        }

        * { box-sizing: border-box; user-select: none; }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            background-color: var(--parchment-bg);
            font-family: 'IM Fell English', serif;
            color: var(--ink-primary);
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        .pointer-events-auto { pointer-events: auto; }

        /* Header */
        header {
            padding: 1rem 2rem;
            background: linear-gradient(to bottom, var(--parchment-bg) 80%, transparent);
            border-bottom: 1px solid var(--gold-leaf);
            display: flex; justify-content: space-between; align-items: center;
        }

        h1 {
            font-family: 'Cinzel', serif; font-weight: 700; margin: 0; font-size: 2rem;
            color: var(--ink-primary); text-shadow: 1px 1px 0px var(--parchment-dark);
            letter-spacing: 2px;
        }
        h1 span { color: var(--rubric-red); }

        .file-controls {
            display: flex; gap: 1rem;
        }

        .btn-text {
            background: var(--parchment-dark); border: 1px solid var(--ink-faded);
            color: var(--ink-primary); padding: 0.5rem 1rem;
            font-family: 'Cinzel', serif; font-weight: bold; cursor: pointer;
            transition: all 0.2s; box-shadow: var(--ui-shadow);
        }
        .btn-text:hover { background: var(--gold-leaf); color: white; border-color: var(--ink-primary); }

        /* Toolbar */
        #toolbar {
            position: absolute; left: 1rem; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 0.5rem;
            background: rgba(243, 233, 210, 0.95); padding: 0.5rem;
            border: var(--border-width) solid var(--ink-primary);
            border-radius: 4px; box-shadow: var(--ui-shadow);
        }

        .tool-btn {
            width: 44px; height: 44px;
            background: var(--parchment-dark); border: 1px solid var(--ink-faded);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-family: 'Cinzel', serif; font-weight: bold; font-size: 1.4rem;
            color: var(--ink-primary); transition: all 0.2s ease; position: relative;
        }

        .tool-btn:hover { background: var(--gold-leaf); color: white; border-color: var(--ink-primary); }
        .tool-btn.active { background: var(--rubric-red); color: white; border-color: var(--ink-primary); box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4); }
        
        .tool-btn:hover::after {
            content: attr(title); position: absolute; left: 110%; top: 50%;
            transform: translateY(-50%); background: var(--ink-primary);
            color: var(--parchment-bg); padding: 0.25rem 0.5rem;
            font-size: 0.8rem; font-family: 'IM Fell English', serif;
            white-space: nowrap; border-radius: 2px; pointer-events: none;
        }

        /* Info Panel */
        #info-panel {
            position: absolute; right: 1rem; top: 6rem; width: 280px;
            background: rgba(243, 233, 210, 0.95);
            border: var(--border-width) solid var(--ink-primary);
            padding: 1rem; box-shadow: var(--ui-shadow);
            display: none;
        }
        
        #info-panel h2 {
            font-family: 'Cinzel', serif; font-size: 1.4rem; margin-top: 0;
            border-bottom: 1px solid var(--ink-faded); padding-bottom: 0.5rem;
            color: var(--rubric-red);
        }

        .info-row {
            display: flex; justify-content: space-between; font-size: 0.9rem;
            margin-bottom: 0.5rem; border-bottom: 1px dashed rgba(92, 77, 60, 0.3);
        }

        #keyframe-list {
            max-height: 100px; overflow-y: auto; font-size: 0.8rem;
            background: rgba(255,255,255,0.3); padding: 0.5rem; margin-top: 0.5rem;
        }

        button.small-btn {
            background: var(--ink-primary); color: var(--parchment-bg); border: none;
            padding: 0.2rem 0.5rem; font-family: 'Cinzel', serif; cursor: pointer;
            font-size: 0.7rem; margin-top: 0.5rem;
        }
        button.small-btn:hover { background: var(--rubric-red); }

        /* Drawing Hint */
        #draw-hint {
            position: absolute; bottom: 6rem; left: 50%; transform: translateX(-50%);
            background: rgba(43, 33, 24, 0.9); color: var(--parchment-bg);
            padding: 0.5rem 1rem; border-radius: 4px; border: 1px solid var(--gold-leaf);
            font-family: 'Cinzel', serif; font-size: 0.9rem;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; text-align: center;
        }
        #draw-hint.visible { opacity: 1; }

        /* Temporal Controls */
        #temporal-controls {
            width: 100%; padding: 1rem 2rem;
            background: linear-gradient(to top, var(--parchment-bg) 80%, transparent);
            border-top: 1px solid var(--gold-leaf);
            display: flex; flex-direction: column; align-items: center; gap: 0.5rem;
        }

        #year-display {
            font-family: 'Cinzel', serif; font-size: 2rem; font-weight: bold;
            color: var(--rubric-red);
        }

        input[type=range] { -webkit-appearance: none; width: 80%; max-width: 800px; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%;
            background: var(--rubric-red); border: 2px solid var(--ink-primary);
            cursor: pointer; margin-top: -10px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: var(--ink-faded); border-radius: 2px;
        }

        #map-canvas { position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; }
        #map-canvas:active { cursor: grabbing; }

        .debug-info {
            position: absolute; bottom: 1rem; right: 1rem; font-size: 0.7rem;
            color: var(--ink-faded); background: rgba(255,255,255,0.3);
            padding: 0.2rem 0.5rem; border-radius: 4px;
        }
        
        /* Hidden file input for loading */
        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <header class="pointer-events-auto">
            <h1>Illumin<span>archism</span></h1>
            <div class="file-controls">
                <button class="btn-text" id="btn-save" title="Download .atlas JSON">üíæ Save Atlas</button>
                <button class="btn-text" id="btn-load" title="Upload .atlas JSON">üìÇ Load Atlas</button>
                <input type="file" id="file-input" accept=".json,.atlas">
            </div>
        </header>

        <div id="toolbar" class="pointer-events-auto">
            <button class="tool-btn active" data-tool="pan" title="Pan Hand">‚úã</button>
            <button class="tool-btn" data-tool="inspect" title="Inspect Region">üîç</button>
            <button class="tool-btn" data-tool="draw" title="Quill (Draw)">‚úé</button>
            <button class="tool-btn" data-tool="erase" title="Scrape (Erase)">‚å´</button>
        </div>

        <div id="info-panel" class="pointer-events-auto">
            <h2 id="info-title">Region Name</h2>
            <div class="info-row"><span>Type:</span> <span id="info-type">Polity</span></div>
            <div class="info-row"><span>Span:</span> <span id="info-span">1000-1200</span></div>
            <div style="margin-top: 0.5rem; font-weight: bold; color: var(--ink-faded);">Recorded Years (Keyframes):</div>
            <div id="keyframe-list"></div>
            <button class="small-btn" id="btn-deselect">Close / Deselect</button>
        </div>

        <div id="draw-hint"></div>

        <div id="temporal-controls" class="pointer-events-auto">
            <div id="year-display">1000 AD</div>
            <input type="range" id="time-slider" min="800" max="1300" value="1000" step="1">
            <div style="font-size: 0.8rem; color: var(--ink-faded);">Drag slider to traverse history</div>
        </div>
        
        <div class="debug-info pointer-events-auto">
            Render: Watercolor/Ink | Mode: Interactive | Entities: Loading...
        </div>
    </div>

    <canvas id="map-canvas"></canvas>

    <script>
        /**
         * ILLUMINARCHISM ENGINE v0.4 - The Scribe's Archive & Watercolor Update
         * 1. Persistence: Save/Load functionality via JSON serialization.
         * 2. Watercolor Shader (Simulated): Multi-pass rendering with blending modes 
         * and vertex jitter to mimic hand-painted ink pooling.
         */

        // --- 1. Configuration & Utils ---
        const CONFIG = {
            ZOOM_SENSITIVITY: 0.001, MIN_ZOOM: 0.1, MAX_ZOOM: 5,
            BACKGROUND_COLOR: '#f3e9d2',
            RESAMPLE_COUNT: 100, // Standardize shapes for morphing
            WATERCOLOR_PASSES: 3, // How many wash layers to draw
            WATERCOLOR_JITTER: 3  // Pixel variance for the wash
        };

        const lerp = (start, end, t) => start * (1 - t) + end * t;

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        // Ray Casting Point-in-Polygon
        function isPointInPolygon(point, vs) {
            let x = point.x, y = point.y, inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                let xi = vs[i].x, yi = vs[i].y, xj = vs[j].x, yj = vs[j].y;
                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        /**
         * Resamples a polygon to a specific number of vertices evenly spaced along perimeter.
         */
        function resamplePolygon(points, targetCount) {
            if (!points || points.length < 3) return points;

            let totalLength = 0;
            for (let i = 0; i < points.length; i++) {
                totalLength += distance(points[i], points[(i + 1) % points.length]);
            }

            const step = totalLength / targetCount;
            const newPoints = [];
            let currentDist = 0;
            let currentIdx = 0;
            let nextIdx = 1;
            let segmentDist = distance(points[0], points[1]);
            let distTraveledOnSegment = 0;

            newPoints.push({ x: points[0].x, y: points[0].y });

            for (let i = 1; i < targetCount; i++) {
                currentDist += step;
                
                while (distTraveledOnSegment + step > segmentDist) {
                    const remainingOnSeg = segmentDist - distTraveledOnSegment;
                    currentDist -= remainingOnSeg; 
                    currentIdx = nextIdx;
                    nextIdx = (nextIdx + 1) % points.length;
                    segmentDist = distance(points[currentIdx], points[nextIdx]);
                    distTraveledOnSegment = 0;
                    if (currentIdx === 0 && distTraveledOnSegment === 0 && i > 1) break; 
                }

                distTraveledOnSegment += step;
                const t = distTraveledOnSegment / segmentDist;
                
                newPoints.push({
                    x: lerp(points[currentIdx].x, points[nextIdx].x, t),
                    y: lerp(points[currentIdx].y, points[nextIdx].y, t)
                });
            }
            return newPoints;
        }

        // --- 2. Data Structures ---

        class HistoricalEntity {
            constructor(id, name, type, color) {
                this.id = id;
                this.name = name;
                this.type = type; 
                this.color = color;
                this.description = "A region defined by its changing borders.";
                this.timeline = []; // Array of { year, geometry }
                this.validRange = { start: -Infinity, end: Infinity };
                this.currentGeometry = null;
            }

            addKeyframe(year, geometry) {
                this.timeline = this.timeline.filter(k => k.year !== year);
                const resampled = resamplePolygon(geometry, CONFIG.RESAMPLE_COUNT);
                this.timeline.push({ year, geometry: resampled });
                this.timeline.sort((a, b) => a.year - b.year);
                
                if(this.timeline.length > 0) {
                    this.validRange.start = Math.min(this.timeline[0].year - 100, this.validRange.start);
                    this.validRange.end = Math.max(this.timeline[this.timeline.length-1].year + 100, this.validRange.end);
                }
            }

            getGeometryAtYear(targetYear) {
                if (targetYear < this.validRange.start || targetYear > this.validRange.end || this.timeline.length === 0) {
                    return null;
                }
                if (this.timeline.length === 1) return this.timeline[0].geometry;

                let prev = null, next = null;
                for (let frame of this.timeline) {
                    if (frame.year <= targetYear) prev = frame;
                    if (frame.year >= targetYear && !next) next = frame;
                }

                if (!prev) return next.geometry;
                if (!next) return prev.geometry;
                if (prev === next) return prev.geometry;

                const t = (targetYear - prev.year) / (next.year - prev.year);
                const morphed = [];
                const count = Math.min(prev.geometry.length, next.geometry.length);
                for(let i = 0; i < count; i++) {
                    morphed.push({
                        x: lerp(prev.geometry[i].x, next.geometry[i].x, t),
                        y: lerp(prev.geometry[i].y, next.geometry[i].y, t)
                    });
                }
                return morphed;
            }

            // Hydration helper: Creates a class instance from a plain JSON object
            static fromJSON(data) {
                const ent = new HistoricalEntity(data.id, data.name, data.type, data.color);
                Object.assign(ent, data);
                return ent;
            }
        }

        // --- 3. Renderer ---
        class MedievalRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d'); 
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.transform = { x: this.width/2, y: this.height/2, k: 1 };
                this.noisePattern = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.createParchmentTexture();
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.createParchmentTexture();
                if(window.illuminarchismApp) window.illuminarchismApp.render();
            }

            createParchmentTexture() {
                const size = 256;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');
                ctx.fillStyle = CONFIG.BACKGROUND_COLOR;
                ctx.fillRect(0,0,size,size);
                // Simple Perlin-ish noise
                const id = ctx.getImageData(0,0,size,size);
                const d = id.data;
                for(let i=0; i<d.length; i+=4) {
                    const n = (Math.random()-0.5)*20;
                    d[i] = Math.min(255, Math.max(0, d[i]+n));
                    d[i+1] = Math.min(255, Math.max(0, d[i+1]+n));
                    d[i+2] = Math.min(255, Math.max(0, d[i+2]+n));
                }
                ctx.putImageData(id, 0, 0);
                this.noisePattern = this.ctx.createPattern(c, 'repeat');
            }

            toWorld(sx, sy) { return { x: (sx - this.transform.x)/this.transform.k, y: (sy - this.transform.y)/this.transform.k }; }
            
            clear() { 
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.fillStyle = this.noisePattern || CONFIG.BACKGROUND_COLOR; 
                this.ctx.fillRect(0, 0, this.width, this.height); 
            }

            draw(entities, hoveredId, selectedId, activeTool) {
                this.clear();
                const ctx = this.ctx;
                const t = this.transform;
                
                ctx.save();
                ctx.translate(t.x, t.y);
                ctx.scale(t.k, t.k);

                // Grid
                this.drawGrid();

                // Entities - Draw in passes to approximate watercolor layers
                entities.forEach(ent => {
                    if (!ent.currentGeometry) return;
                    const isHovered = ent.id === hoveredId;
                    const isSelected = ent.id === selectedId;
                    
                    this.drawWatercolorEntity(ent, isHovered, isSelected, activeTool);
                });
                
                ctx.restore();
            }

            drawWatercolorEntity(ent, isHovered, isSelected, activeTool) {
                const ctx = this.ctx;
                const pts = ent.currentGeometry;
                if (!pts || pts.length === 0) return;

                // 1. Watercolor Wash (Multiple transparent passes with jitter)
                ctx.globalCompositeOperation = 'multiply'; // Blend colors like ink/paint
                
                // Determine base color opacity
                let baseAlpha = 0.15;
                if (isHovered && activeTool === 'inspect') baseAlpha = 0.3;
                if (isSelected) baseAlpha = 0.4;

                ctx.fillStyle = this.hexToRgba(ent.color, baseAlpha);

                for (let pass = 0; pass < CONFIG.WATERCOLOR_PASSES; pass++) {
                    ctx.beginPath();
                    // First point
                    let startJitter = this.getJitter(pass);
                    ctx.moveTo(pts[0].x + startJitter.x, pts[0].y + startJitter.y);
                    
                    // Subsequent points
                    for(let i=1; i<pts.length; i++) {
                        let j = this.getJitter(pass);
                        ctx.lineTo(pts[i].x + j.x, pts[i].y + j.y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                // 2. Ink Stroke (Defined outline)
                ctx.globalCompositeOperation = 'source-over'; // Draw ink on top
                ctx.beginPath();
                this.tracePath(pts);
                ctx.closePath();

                if (isSelected) {
                    ctx.strokeStyle = '#8a3324'; // Red rubric selection
                    ctx.lineWidth = 3 / this.transform.k;
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 10;
                } else {
                    ctx.strokeStyle = '#2b2118'; // Iron gall ink
                    ctx.lineWidth = 1.5 / this.transform.k;
                    ctx.shadowBlur = 0;
                }
                ctx.lineJoin = 'round';
                ctx.stroke();

                // 3. Label
                if (this.transform.k > 0.5) {
                    this.drawLabel(ent, isSelected);
                }
            }

            getJitter(seed) {
                // Pseudo-random jitter based on pass index
                const amount = CONFIG.WATERCOLOR_JITTER / this.transform.k;
                return {
                    x: (Math.random() - 0.5) * amount * (seed + 1),
                    y: (Math.random() - 0.5) * amount * (seed + 1)
                };
            }

            drawLabel(ent, isSelected) {
                let sx=0, sy=0;
                ent.currentGeometry.forEach(p => { sx+=p.x; sy+=p.y; });
                const cx = sx/ent.currentGeometry.length;
                const cy = sy/ent.currentGeometry.length;

                this.ctx.fillStyle = isSelected ? '#fff' : '#8a3324';
                if(isSelected) this.ctx.shadowBlur = 4;
                this.ctx.font = '14px "Cinzel"';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(ent.name, cx, cy);
                this.ctx.shadowBlur = 0;
            }

            drawDraft(points, cursor, transform) {
                if (!points || points.length === 0) return;
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(transform.x, transform.y);
                ctx.scale(transform.k, transform.k);
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                if(cursor) ctx.lineTo(cursor.x, cursor.y);
                
                ctx.strokeStyle = '#8a3324';
                ctx.lineWidth = 2/transform.k;
                ctx.setLineDash([5/transform.k, 5/transform.k]);
                ctx.stroke();
                
                points.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 4/transform.k, 0, Math.PI*2);
                    ctx.fillStyle='#8a3324'; ctx.fill();
                });
                ctx.restore();
            }

            tracePath(pts) {
                if(!pts.length) return;
                this.ctx.moveTo(pts[0].x, pts[0].y);
                for(let i=1; i<pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);
            }

            drawGrid() {
                const ctx = this.ctx;
                const sz = 100; const cnt = 30;
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(138, 51, 36, 0.05)';
                ctx.lineWidth = 1/this.transform.k;
                for(let i=-cnt; i<=cnt; i++) {
                    ctx.moveTo(i*sz, -cnt*sz); ctx.lineTo(i*sz, cnt*sz);
                    ctx.moveTo(-cnt*sz, i*sz); ctx.lineTo(cnt*sz, i*sz);
                }
                ctx.stroke();
            }

            hexToRgba(hex, a) {
                const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
                return `rgba(${r},${g},${b},${a})`;
            }
        }

        // --- 4. Input & Interaction ---
        class InputController {
            constructor(app) {
                this.app = app;
                this.renderer = app.renderer;
                this.isDragging = false;
                this.lastX=0; this.lastY=0; this.hoverThrottle=0;
                this.init();
            }

            init() {
                const c = this.renderer.canvas;
                c.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const d = -Math.sign(e.deltaY);
                    const s = 1 + (d*0.1);
                    const t = this.renderer.transform;
                    const mx = e.offsetX, my = e.offsetY;
                    const wp = this.renderer.toWorld(mx, my);
                    t.k = Math.max(CONFIG.MIN_ZOOM, Math.min(CONFIG.MAX_ZOOM, t.k * s));
                    t.x = mx - (wp.x * t.k);
                    t.y = my - (wp.y * t.k);
                    this.app.render();
                });

                c.addEventListener('mousedown', (e) => {
                    if (this.app.activeTool === 'pan') {
                        this.isDragging = true;
                        this.lastX = e.clientX; this.lastY = e.clientY;
                        c.style.cursor = 'grabbing';
                    } else if (this.app.activeTool === 'inspect' && this.app.hoveredEntityId) {
                        this.app.selectEntity(this.app.hoveredEntityId);
                    } else if (this.app.activeTool === 'draw') {
                        const wp = this.renderer.toWorld(e.offsetX, e.offsetY);
                        this.app.addDraftPoint(wp);
                    } else if (this.app.activeTool === 'erase' && this.app.hoveredEntityId) {
                        this.app.deleteEntity(this.app.hoveredEntityId);
                    }
                    if (this.app.activeTool !== 'inspect' && this.app.activeTool !== 'draw') this.app.deselect();
                });

                window.addEventListener('mousemove', (e) => {
                    if (this.isDragging && this.app.activeTool === 'pan') {
                        const dx = e.clientX - this.lastX;
                        const dy = e.clientY - this.lastY;
                        this.lastX = e.clientX; this.lastY = e.clientY;
                        this.renderer.transform.x += dx;
                        this.renderer.transform.y += dy;
                        this.app.render();
                        return;
                    }
                    const wp = this.renderer.toWorld(e.offsetX, e.offsetY);
                    if (this.app.activeTool === 'draw') { this.app.updateDraftCursor(wp); return; }
                    if (this.app.activeTool === 'inspect' || this.app.activeTool === 'erase') {
                        const now = Date.now();
                        if (now - this.hoverThrottle > 30) {
                            this.hoverThrottle = now;
                            this.app.checkHover(wp);
                        }
                    }
                });

                window.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    if(this.app.activeTool === 'pan') c.style.cursor = 'grab';
                });

                c.addEventListener('dblclick', (e) => {
                    if (this.app.activeTool === 'draw') {
                        e.preventDefault();
                        this.app.commitDraft();
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if (this.app.activeTool === 'draw') {
                        if (e.key === 'Enter') this.app.commitDraft();
                        if (e.key === 'Escape') this.app.cancelDraft();
                    }
                });
            }
        }

        // --- 5. App Logic ---
        class IlluminarchismApp {
            constructor() {
                this.renderer = new MedievalRenderer('map-canvas');
                this.input = new InputController(this);
                this.entities = [];
                this.hoveredEntityId = null;
                this.selectedEntityId = null;
                this.currentYear = 1000;
                this.draftPoints = [];
                this.draftCursor = null;
                this.activeTool = 'pan'; 

                this.initData();
                this.initUI();
                this.updateEntities();
                this.render();
            }

            initData() {
                // Basic initial data
                const blue = new HistoricalEntity('blue_kg', 'Regnum Caeruleum', 'polity', '#264e86');
                blue.addKeyframe(800, [{x:-100,y:-100}, {x:100,y:-100}, {x:100,y:100}, {x:-100,y:100}]);
                blue.addKeyframe(1200, [{x:-200,y:-150}, {x:250,y:-120}, {x:200,y:200}, {x:-180,y:180}]);
                this.entities.push(blue);
            }

            initUI() {
                const slider = document.getElementById('time-slider');
                const display = document.getElementById('year-display');
                
                slider.addEventListener('input', (e) => {
                    this.currentYear = parseInt(e.target.value);
                    display.textContent = `${this.currentYear} AD`;
                    this.updateEntities();
                    this.render();
                });

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(t => t.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        this.setTool(e.currentTarget.dataset.tool);
                    });
                });

                document.getElementById('btn-deselect').addEventListener('click', () => this.deselect());

                // Persistence Handlers
                document.getElementById('btn-save').addEventListener('click', () => this.saveAtlas());
                const fileInput = document.getElementById('file-input');
                document.getElementById('btn-load').addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.loadAtlas(e));
            }

            // --- Persistence Methods ---

            saveAtlas() {
                // Serialize entities to JSON
                const data = JSON.stringify(this.entities, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create temp link to download
                const a = document.createElement('a');
                a.href = url;
                a.download = `atlas_backup_${new Date().toISOString().slice(0,10)}.atlas`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            loadAtlas(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const rawData = JSON.parse(e.target.result);
                        // Hydrate plain objects back into HistoricalEntity instances
                        this.entities = rawData.map(obj => HistoricalEntity.fromJSON(obj));
                        this.updateEntities();
                        this.render();
                        alert('Atlas loaded successfully from the archives.');
                    } catch (err) {
                        console.error(err);
                        alert('Failed to parse the atlas file. The archives are corrupted.');
                    }
                };
                reader.readAsText(file);
                // Reset input
                event.target.value = '';
            }

            // --- Tool & Draw Logic ---

            setTool(name) {
                this.activeTool = name;
                this.cancelDraft();
                
                const hint = document.getElementById('draw-hint');
                if (name === 'draw') {
                    hint.classList.add('visible');
                    if (this.selectedEntityId) {
                        const ent = this.entities.find(e => e.id === this.selectedEntityId);
                        hint.textContent = `EDITING: ${ent.name}. Draw new borders for year ${this.currentYear}.`;
                    } else {
                        hint.textContent = "Click to place points. Double-click to create NEW region.";
                    }
                } else {
                    hint.classList.remove('visible');
                }

                const c = this.renderer.canvas;
                if(name==='pan') c.style.cursor='grab';
                else if(name==='inspect') c.style.cursor='default';
                else if(name==='draw') c.style.cursor='crosshair';
                else if(name==='erase') c.style.cursor='not-allowed';
                
                this.render();
            }

            addDraftPoint(p) {
                const last = this.draftPoints[this.draftPoints.length - 1];
                if (last && Math.abs(last.x - p.x) < 2 && Math.abs(last.y - p.y) < 2) return;
                this.draftPoints.push(p);
                this.render();
            }

            updateDraftCursor(p) { this.draftCursor = p; this.render(); }

            commitDraft() {
                if (this.draftPoints.length < 3) return;

                if (this.selectedEntityId) {
                    const ent = this.entities.find(e => e.id === this.selectedEntityId);
                    if (ent) {
                        ent.addKeyframe(this.currentYear, [...this.draftPoints]);
                        this.updateInfoPanel(ent);
                    }
                } else {
                    const id = 'custom_' + Date.now();
                    const colors = ['#8a3324', '#264e86', '#c5a059', '#3a5f3a', '#5c3c92'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const newEnt = new HistoricalEntity(id, "New Realm", 'polity', color);
                    
                    newEnt.addKeyframe(this.currentYear, [...this.draftPoints]);
                    newEnt.validRange.start = this.currentYear - 200;
                    newEnt.validRange.end = this.currentYear + 200;
                    this.entities.push(newEnt);
                    this.selectEntity(id);
                }

                this.draftPoints = [];
                this.draftCursor = null;
                this.updateEntities();
                this.render();
                if(this.activeTool === 'draw') this.setTool('draw');
            }

            cancelDraft() { this.draftPoints=[]; this.draftCursor=null; this.render(); }

            deleteEntity(id) {
                this.entities = this.entities.filter(e => e.id !== id);
                if(this.selectedEntityId === id) this.deselect();
                this.hoveredEntityId = null;
                this.updateEntities();
                this.render();
            }

            deselect() {
                this.selectedEntityId = null;
                document.getElementById('info-panel').style.display = 'none';
                if (this.activeTool === 'draw') this.setTool('draw');
                this.render();
            }

            selectEntity(id) {
                this.selectedEntityId = id;
                const ent = this.entities.find(e => e.id === id);
                if (ent) {
                    const p = document.getElementById('info-panel');
                    p.style.display = 'block';
                    document.getElementById('info-title').textContent = ent.name;
                    document.getElementById('info-type').textContent = ent.type;
                    document.getElementById('info-span').textContent = `${ent.validRange.start} - ${ent.validRange.end}`;
                    this.updateInfoPanel(ent);
                    if (this.activeTool === 'draw') this.setTool('draw');
                }
                this.render();
            }

            updateInfoPanel(ent) {
                const list = document.getElementById('keyframe-list');
                list.innerHTML = '';
                ent.timeline.forEach(kf => {
                    const div = document.createElement('div');
                    div.textContent = `‚Ä¢ ${kf.year} AD`;
                    div.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
                    list.appendChild(div);
                });
            }

            checkHover(wp) {
                if (this.activeTool !== 'inspect' && this.activeTool !== 'erase') return;
                let fid = null;
                for (let i = this.entities.length - 1; i >= 0; i--) {
                    const e = this.entities[i];
                    if (!e.currentGeometry) continue;
                    if (isPointInPolygon(wp, e.currentGeometry)) { fid = e.id; break; }
                }
                if (fid !== this.hoveredEntityId) {
                    this.hoveredEntityId = fid;
                    this.renderer.canvas.style.cursor = (this.activeTool==='erase') ? (fid?'pointer':'not-allowed') : (fid?'pointer':'default');
                    this.render();
                }
            }

            updateEntities() {
                let cnt = 0;
                this.entities.forEach(ent => {
                    ent.currentGeometry = ent.getGeometryAtYear(this.currentYear);
                    if (ent.currentGeometry) cnt++;
                });
                const d = document.querySelector('.debug-info');
                if(d) d.textContent = `Year: ${this.currentYear} | Active: ${cnt} | Selected: ${this.selectedEntityId ? 'Yes' : 'No'}`;
            }

            render() {
                this.renderer.draw(this.entities, this.hoveredEntityId, this.selectedEntityId, this.activeTool);
                if (this.activeTool === 'draw' && this.draftPoints.length > 0) {
                    this.renderer.drawDraft(this.draftPoints, this.draftCursor, this.renderer.transform);
                }
            }
        }

        window.onload = () => { window.illuminarchismApp = new IlluminarchismApp(); };
    </script>
</body>
</html>
