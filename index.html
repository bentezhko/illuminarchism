<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Illuminarchism | The Living Atlas</title>
    
    <!-- Google Fonts for Medieval Aesthetic -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Palette: Medieval Manuscript */
            --parchment-bg: #f3e9d2;
            --parchment-dark: #e0d0b0;
            --ink-primary: #2b2118;
            --ink-faded: #5c4d3c;
            --rubric-red: #8a3324;
            --gold-leaf: #c5a059;
            --lapis-lazuli: #264e86;
            --verdigris: #43b3ae; 
            
            --ui-shadow: 0 4px 6px rgba(43, 33, 24, 0.2);
            --border-width: 2px;
        }

        * { box-sizing: border-box; user-select: none; }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            background-color: var(--parchment-bg);
            font-family: 'IM Fell English', serif;
            color: var(--ink-primary);
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        .pointer-events-auto { pointer-events: auto; }

        /* Header */
        header {
            padding: 1rem 2rem;
            background: linear-gradient(to bottom, var(--parchment-bg) 80%, transparent);
            border-bottom: 1px solid var(--gold-leaf);
            display: flex; justify-content: space-between; align-items: center;
        }

        h1 {
            font-family: 'Cinzel', serif; font-weight: 700; margin: 0; font-size: 2rem;
            color: var(--ink-primary); text-shadow: 1px 1px 0px var(--parchment-dark);
            letter-spacing: 2px;
        }
        h1 span { color: var(--rubric-red); }

        .file-controls { display: flex; gap: 1rem; }

        .btn-text {
            background: var(--parchment-dark); border: 1px solid var(--ink-faded);
            color: var(--ink-primary); padding: 0.5rem 1rem;
            font-family: 'Cinzel', serif; font-weight: bold; cursor: pointer;
            transition: all 0.2s; box-shadow: var(--ui-shadow);
        }
        .btn-text:hover { background: var(--gold-leaf); color: white; border-color: var(--ink-primary); }

        /* Toolbar */
        #toolbar {
            position: absolute; left: 1rem; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 0.5rem;
            background: rgba(243, 233, 210, 0.95); padding: 0.5rem;
            border: var(--border-width) solid var(--ink-primary);
            border-radius: 4px; box-shadow: var(--ui-shadow);
            align-items: center;
        }

        .tool-btn {
            width: 44px; height: 44px;
            background: var(--parchment-dark); border: 1px solid var(--ink-faded);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-family: 'Cinzel', serif; font-weight: bold; font-size: 1.4rem;
            color: var(--ink-primary); transition: all 0.2s ease; position: relative;
        }
        .tool-btn:hover { background: var(--gold-leaf); color: white; border-color: var(--ink-primary); }
        .tool-btn.active { background: var(--rubric-red); color: white; border-color: var(--ink-primary); box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4); }
        .tool-btn:hover::after {
            content: attr(title); position: absolute; left: 110%; top: 50%;
            transform: translateY(-50%); background: var(--ink-primary);
            color: var(--parchment-bg); padding: 0.25rem 0.5rem;
            font-size: 0.8rem; font-family: 'IM Fell English', serif;
            white-space: nowrap; border-radius: 2px; pointer-events: none; z-index: 20;
        }

        #draw-type-select {
            margin-top: 0.5rem; padding: 0.2rem;
            font-family: 'Cinzel', serif; font-size: 0.8rem;
            background: var(--parchment-bg); border: 1px solid var(--ink-faded);
            width: 100%; text-align: center;
        }

        /* Layers Panel */
        #layer-panel {
            position: absolute; left: 1rem; top: 7rem; 
            background: rgba(243, 233, 210, 0.95);
            padding: 0.5rem; border: var(--border-width) solid var(--ink-primary);
            border-radius: 4px; box-shadow: var(--ui-shadow);
            font-family: 'Cinzel', serif; font-size: 0.8rem;
        }
        .layer-toggle { display: block; margin-bottom: 0.3rem; cursor: pointer; }
        .layer-toggle input { margin-right: 0.5rem; }

        /* Info Panel */
        #info-panel {
            position: absolute; right: 1rem; top: 6rem; width: 280px;
            background: rgba(243, 233, 210, 0.95);
            border: var(--border-width) solid var(--ink-primary);
            padding: 1rem; box-shadow: var(--ui-shadow); display: none;
        }
        
        .info-input {
            width: 100%; background: transparent; border: none;
            border-bottom: 1px dashed var(--ink-faded);
            font-family: 'Cinzel', serif; font-size: 1.2rem;
            color: var(--rubric-red); margin-bottom: 0.5rem; outline: none;
        }
        .info-input:focus { border-bottom: 1px solid var(--rubric-red); }

        .info-row {
            display: flex; justify-content: space-between; font-size: 0.9rem;
            margin-bottom: 0.5rem; border-bottom: 1px dashed rgba(92, 77, 60, 0.3);
            align-items: center;
        }

        input[type="color"] {
            -webkit-appearance: none; border: none; width: 24px; height: 24px;
            cursor: pointer; background: none; padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid var(--ink-primary); border-radius: 50%; }

        #keyframe-list {
            max-height: 100px; overflow-y: auto; font-size: 0.8rem;
            background: rgba(255,255,255,0.3); padding: 0.5rem; margin-top: 0.5rem;
        }

        button.small-btn {
            background: var(--ink-primary); color: var(--parchment-bg); border: none;
            padding: 0.2rem 0.5rem; font-family: 'Cinzel', serif; cursor: pointer;
            font-size: 0.7rem; margin-top: 0.5rem;
        }
        button.small-btn:hover { background: var(--rubric-red); }

        /* Drawing Hint */
        #draw-hint {
            position: absolute; bottom: 6rem; left: 50%; transform: translateX(-50%);
            background: rgba(43, 33, 24, 0.9); color: var(--parchment-bg);
            padding: 0.5rem 1rem; border-radius: 4px; border: 1px solid var(--gold-leaf);
            font-family: 'Cinzel', serif; font-size: 0.9rem;
            pointer-events: none; opacity: 0; transition: opacity 0.3s; text-align: center;
        }
        #draw-hint.visible { opacity: 1; }

        /* Temporal Controls */
        #temporal-controls {
            width: 100%; padding: 1rem 2rem;
            background: linear-gradient(to top, var(--parchment-bg) 80%, transparent);
            border-top: 1px solid var(--gold-leaf);
            display: flex; flex-direction: column; align-items: center; gap: 0.5rem;
        }

        .timeline-wrapper {
            display: flex; width: 100%; max-width: 800px; align-items: center; gap: 1rem;
        }

        #year-display {
            font-family: 'Cinzel', serif; font-size: 2rem; font-weight: bold;
            color: var(--rubric-red); min-width: 150px; text-align: center;
        }

        #btn-play {
            width: 40px; height: 40px; border-radius: 50%; border: 2px solid var(--ink-primary);
            background: var(--rubric-red); color: white; font-size: 1.2rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        #btn-play:hover { background: var(--gold-leaf); }

        input[type=range] { -webkit-appearance: none; flex-grow: 1; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%;
            background: var(--ink-primary); border: 2px solid var(--parchment-bg);
            cursor: pointer; margin-top: -10px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: var(--ink-faded); border-radius: 2px;
        }

        #map-canvas { position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; }
        #map-canvas:active { cursor: grabbing; }

        .debug-info {
            position: absolute; bottom: 1rem; right: 1rem; font-size: 0.7rem;
            color: var(--ink-faded); background: rgba(255,255,255,0.3);
            padding: 0.2rem 0.5rem; border-radius: 4px;
        }
        
        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <header class="pointer-events-auto">
            <h1>Illumin<span>archism</span></h1>
            <div class="file-controls">
                <button class="btn-text" id="btn-save" title="Download .atlas JSON">üíæ Save</button>
                <button class="btn-text" id="btn-load" title="Upload .atlas JSON">üìÇ Load</button>
                <input type="file" id="file-input" accept=".json,.atlas">
            </div>
        </header>

        <div id="toolbar" class="pointer-events-auto">
            <button class="tool-btn active" data-tool="pan" title="Pan Hand">‚úã</button>
            <button class="tool-btn" data-tool="inspect" title="Inspect Region">üîç</button>
            <div style="border-top: 1px solid var(--ink-faded); width: 100%; margin: 0.2rem 0;"></div>
            <select id="draw-type-select" class="pointer-events-auto" title="Entity Type">
                <option value="polity">Polity</option>
                <option value="river">River</option>
                <option value="city">City</option>
            </select>
            <button class="tool-btn" data-tool="draw" title="Quill (Draw)">‚úé</button>
            <button class="tool-btn" data-tool="erase" title="Scrape (Erase)">‚å´</button>
        </div>

        <div id="layer-panel" class="pointer-events-auto">
            <div style="border-bottom: 1px solid var(--ink-faded); margin-bottom: 0.5rem; color: var(--rubric-red);">Vellum Layers</div>
            <label class="layer-toggle"><input type="checkbox" id="layer-polity" checked> Realms</label>
            <label class="layer-toggle"><input type="checkbox" id="layer-river" checked> Waterways</label>
            <label class="layer-toggle"><input type="checkbox" id="layer-city" checked> Settlements</label>
        </div>

        <div id="info-panel" class="pointer-events-auto">
            <!-- Editable Name -->
            <input type="text" id="info-name-input" class="info-input" value="Region Name">
            
            <div class="info-row">
                <span>Type:</span> 
                <span id="info-type" style="font-weight:bold;">Polity</span>
            </div>
            <div class="info-row">
                <span>Pigment:</span>
                <input type="color" id="info-color-input" title="Change Color">
            </div>
            <div class="info-row"><span>Span:</span> <span id="info-span">1000-1200</span></div>
            
            <div style="margin-top: 0.5rem; font-weight: bold; color: var(--ink-faded);">Recorded Years:</div>
            <div id="keyframe-list"></div>
            
            <div style="display:flex; gap:0.5rem; margin-top: 1rem;">
                <button class="small-btn" id="btn-update-meta" style="flex:1;">Update</button>
                <button class="small-btn" id="btn-deselect">Close</button>
            </div>
        </div>

        <div id="draw-hint"></div>

        <div id="temporal-controls" class="pointer-events-auto">
            <div id="year-display">1000 AD</div>
            <div class="timeline-wrapper">
                <button id="btn-play" title="Play History">‚ñ∂</button>
                <input type="range" id="time-slider" min="800" max="1300" value="1000" step="1">
            </div>
            <div style="font-size: 0.8rem; color: var(--ink-faded);">The Chronometer</div>
        </div>
        
        <div class="debug-info pointer-events-auto">
            Render: Watercolor/Ink | Mode: Interactive | Entities: Loading...
        </div>
    </div>

    <canvas id="map-canvas"></canvas>

    <script>
        /**
         * ILLUMINARCHISM ENGINE v0.7 - The Geometric Stabilizer
         * 1. Smart Vertex Alignment: Prevents "flipping" by rotating polygon indices to match previous keyframe.
         * 2. Winding Normalization: Enforces Clockwise winding for all polygons.
         * 3. River Stability: Detects and flips reversed river segments.
         */

        const CONFIG = {
            ZOOM_SENSITIVITY: 0.001, MIN_ZOOM: 0.1, MAX_ZOOM: 5,
            BACKGROUND_COLOR: '#f3e9d2',
            RESAMPLE_COUNT: 100, 
            WATERCOLOR_PASSES: 3, 
            WATERCOLOR_JITTER: 3,
            ANIMATION_SPEED: 200 
        };

        const lerp = (start, end, t) => start * (1 - t) + end * t;

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        // Squared distance helper for performance
        function distSq(p1, p2) {
            return Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
        }

        function isPointInPolygon(point, vs) {
            let x = point.x, y = point.y, inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                let xi = vs[i].x, yi = vs[i].y, xj = vs[j].x, yj = vs[j].y;
                let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function distanceToSegment(p, v, w) {
            function sqr(x) { return x * x }
            function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
            let l2 = dist2(v, w);
            if (l2 === 0) return distance(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return distance(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
        }

        // --- Geometric Helpers ---

        // Calculate signed area to determine winding order
        function getSignedArea(points) {
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                let j = (i + 1) % points.length;
                area += (points[i].x * points[j].y) - (points[j].x * points[i].y);
            }
            return area / 2.0;
        }

        // Ensure Polygon is Clockwise
        function enforceClockwise(points) {
            if (getSignedArea(points) < 0) {
                return points.reverse(); // Was CCW, make CW
            }
            return points;
        }

        // Optimal Alignment: Shift indices of poly2 to match poly1
        // Used for closed shapes (Polities)
        function alignPolygonClosed(poly1, poly2) {
            if (poly1.length !== poly2.length) return poly2;
            
            let minTotalDist = Infinity;
            let bestOffset = 0;
            const N = poly1.length;

            // Brute force check all N rotations (N=100, so 10k ops, very fast)
            for (let offset = 0; offset < N; offset++) {
                let currentDist = 0;
                for (let i = 0; i < N; i++) {
                    currentDist += distSq(poly1[i], poly2[(i + offset) % N]);
                }
                if (currentDist < minTotalDist) {
                    minTotalDist = currentDist;
                    bestOffset = offset;
                }
            }

            // Create new rotated array
            const aligned = [];
            for (let i = 0; i < N; i++) {
                aligned.push(poly2[(i + bestOffset) % N]);
            }
            return aligned;
        }

        // Optimal Alignment: Check Reverse for open shapes
        // Used for open shapes (Rivers)
        function alignPolylineOpen(poly1, poly2) {
            // Check distance as-is
            let distNormal = 0;
            for(let i=0; i<Math.min(poly1.length, poly2.length); i++) {
                distNormal += distSq(poly1[i], poly2[i]);
            }

            // Check distance reversed
            let distReversed = 0;
            const len = poly2.length;
            for(let i=0; i<Math.min(poly1.length, poly2.length); i++) {
                distReversed += distSq(poly1[i], poly2[len - 1 - i]);
            }

            if (distReversed < distNormal) {
                return [...poly2].reverse();
            }
            return poly2;
        }

        function resampleGeometry(points, targetCount, isClosed = true) {
            if (!points || points.length < 2) return points;
            
            // Standardize winding for closed shapes before resampling
            let sourcePoints = isClosed ? enforceClockwise([...points]) : points;

            let totalLength = 0;
            const segments = isClosed ? sourcePoints.length : sourcePoints.length - 1;
            
            for (let i = 0; i < segments; i++) {
                totalLength += distance(sourcePoints[i], sourcePoints[(i + 1) % sourcePoints.length]);
            }

            const step = totalLength / targetCount;
            const newPoints = [];
            let currentDist = 0, currentIdx = 0, nextIdx = 1;
            let segmentDist = distance(sourcePoints[0], sourcePoints[1]);
            let distTraveledOnSegment = 0;

            newPoints.push({ x: sourcePoints[0].x, y: sourcePoints[0].y });

            const loopLimit = isClosed ? targetCount : targetCount - 1;

            for (let i = 1; i < loopLimit; i++) {
                currentDist += step;
                while (distTraveledOnSegment + step > segmentDist) {
                    const remainingOnSeg = segmentDist - distTraveledOnSegment;
                    currentDist -= remainingOnSeg; 
                    currentIdx = nextIdx;
                    nextIdx = (nextIdx + 1);
                    if (isClosed) nextIdx = nextIdx % sourcePoints.length;
                    if (!isClosed && nextIdx >= sourcePoints.length) break;
                    segmentDist = distance(sourcePoints[currentIdx], sourcePoints[nextIdx]);
                    distTraveledOnSegment = 0;
                }
                distTraveledOnSegment += step;
                const t = distTraveledOnSegment / segmentDist;
                newPoints.push({
                    x: lerp(sourcePoints[currentIdx].x, sourcePoints[nextIdx].x, t),
                    y: lerp(sourcePoints[currentIdx].y, sourcePoints[nextIdx].y, t)
                });
            }
            if(!isClosed && newPoints.length < targetCount) newPoints.push({...sourcePoints[sourcePoints.length-1]});
            
            return newPoints;
        }

        // --- 2. Data Structures ---
        class HistoricalEntity {
            constructor(id, name, type, color) {
                this.id = id;
                this.name = name;
                this.type = type; 
                this.color = color;
                this.description = "A mapped entity.";
                this.timeline = []; 
                this.validRange = { start: -Infinity, end: Infinity };
                this.currentGeometry = null;
            }

            addKeyframe(year, geometry) {
                this.timeline = this.timeline.filter(k => k.year !== year);
                let resampled;
                if (this.type === 'city') {
                    resampled = geometry; 
                } else {
                    const isClosed = (this.type === 'polity');
                    resampled = resampleGeometry(geometry, CONFIG.RESAMPLE_COUNT, isClosed);
                }
                this.timeline.push({ year, geometry: resampled });
                this.timeline.sort((a, b) => a.year - b.year);
                if(this.timeline.length > 0) {
                    this.validRange.start = Math.min(this.timeline[0].year - 100, this.validRange.start);
                    this.validRange.end = Math.max(this.timeline[this.timeline.length-1].year + 100, this.validRange.end);
                }
            }

            getGeometryAtYear(targetYear) {
                if (targetYear < this.validRange.start || targetYear > this.validRange.end || this.timeline.length === 0) return null;
                if (this.timeline.length === 1) return this.timeline[0].geometry;

                let prev = null, next = null;
                for (let frame of this.timeline) {
                    if (frame.year <= targetYear) prev = frame;
                    if (frame.year >= targetYear && !next) next = frame;
                }

                if (!prev) return next.geometry;
                if (!next) return prev.geometry;
                if (prev === next) return prev.geometry;

                // --- STABILIZER LOGIC ---
                // Before interpolating, ensure 'next' is aligned to 'prev'
                let targetGeo = next.geometry;
                if (this.type === 'polity') {
                    targetGeo = alignPolygonClosed(prev.geometry, next.geometry);
                } else if (this.type === 'river') {
                    targetGeo = alignPolylineOpen(prev.geometry, next.geometry);
                }
                // ------------------------

                const t = (targetYear - prev.year) / (next.year - prev.year);
                const morphed = [];
                const count = Math.min(prev.geometry.length, targetGeo.length);
                for(let i = 0; i < count; i++) {
                    morphed.push({
                        x: lerp(prev.geometry[i].x, targetGeo[i].x, t),
                        y: lerp(prev.geometry[i].y, targetGeo[i].y, t)
                    });
                }
                return morphed;
            }

            static fromJSON(data) {
                const ent = new HistoricalEntity(data.id, data.name, data.type, data.color);
                Object.assign(ent, data);
                return ent;
            }
        }

        // --- 3. Renderer ---
        class MedievalRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d'); 
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.transform = { x: this.width/2, y: this.height/2, k: 1 };
                this.noisePattern = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.createParchmentTexture();
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.createParchmentTexture();
                if(window.illuminarchismApp) window.illuminarchismApp.render();
            }

            createParchmentTexture() {
                const size = 256;
                const c = document.createElement('canvas');
                c.width = size; c.height = size;
                const ctx = c.getContext('2d');
                ctx.fillStyle = CONFIG.BACKGROUND_COLOR;
                ctx.fillRect(0,0,size,size);
                const id = ctx.getImageData(0,0,size,size);
                const d = id.data;
                for(let i=0; i<d.length; i+=4) {
                    const n = (Math.random()-0.5)*20;
                    d[i] = Math.min(255, Math.max(0, d[i]+n));
                    d[i+1] = Math.min(255, Math.max(0, d[i+1]+n));
                    d[i+2] = Math.min(255, Math.max(0, d[i+2]+n));
                }
                ctx.putImageData(id, 0, 0);
                this.noisePattern = this.ctx.createPattern(c, 'repeat');
            }

            toWorld(sx, sy) { return { x: (sx - this.transform.x)/this.transform.k, y: (sy - this.transform.y)/this.transform.k }; }
            
            clear() { 
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.fillStyle = this.noisePattern || CONFIG.BACKGROUND_COLOR; 
                this.ctx.fillRect(0, 0, this.width, this.height); 
            }

            draw(entities, hoveredId, selectedId, activeTool, layerVisibility) {
                this.clear();
                const ctx = this.ctx;
                const t = this.transform;
                
                ctx.save();
                ctx.translate(t.x, t.y);
                ctx.scale(t.k, t.k);

                this.drawGrid();

                const sorted = [...entities].sort((a,b) => {
                    const order = { 'river': 0, 'polity': 1, 'city': 2 };
                    return order[a.type] - order[b.type];
                });

                sorted.forEach(ent => {
                    if (!ent.currentGeometry) return;
                    if (!layerVisibility[ent.type]) return; 

                    const isHovered = ent.id === hoveredId;
                    const isSelected = ent.id === selectedId;
                    
                    if (ent.type === 'polity') this.drawPolity(ent, isHovered, isSelected, activeTool);
                    else if (ent.type === 'river') this.drawRiver(ent, isHovered, isSelected);
                    else if (ent.type === 'city') this.drawCity(ent, isHovered, isSelected);
                });
                
                ctx.restore();
            }

            drawPolity(ent, isHovered, isSelected, activeTool) {
                const ctx = this.ctx;
                const pts = ent.currentGeometry;
                if (!pts.length) return;

                ctx.globalCompositeOperation = 'multiply';
                let baseAlpha = (isSelected || (isHovered && activeTool === 'inspect')) ? 0.3 : 0.15;
                ctx.fillStyle = this.hexToRgba(ent.color, baseAlpha);

                for (let pass = 0; pass < CONFIG.WATERCOLOR_PASSES; pass++) {
                    ctx.beginPath();
                    let startJitter = this.getJitter(pass);
                    ctx.moveTo(pts[0].x + startJitter.x, pts[0].y + startJitter.y);
                    for(let i=1; i<pts.length; i++) {
                        let j = this.getJitter(pass);
                        ctx.lineTo(pts[i].x + j.x, pts[i].y + j.y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.globalCompositeOperation = 'source-over';
                ctx.beginPath();
                this.tracePath(pts, true); 
                
                if (isSelected) {
                    ctx.strokeStyle = '#8a3324'; ctx.lineWidth = 3/this.transform.k;
                    ctx.shadowColor = '#000'; ctx.shadowBlur = 10;
                } else {
                    ctx.strokeStyle = '#2b2118'; ctx.lineWidth = 1.5/this.transform.k;
                    ctx.shadowBlur = 0;
                }
                ctx.stroke();

                if (this.transform.k > 0.5) this.drawLabel(ent, isSelected);
            }

            drawRiver(ent, isHovered, isSelected) {
                const ctx = this.ctx;
                const pts = ent.currentGeometry;
                if (!pts.length) return;

                ctx.globalCompositeOperation = 'multiply';
                ctx.beginPath();
                this.tracePath(pts, false); 

                ctx.strokeStyle = isSelected ? '#8a3324' : ent.color; 
                ctx.lineWidth = (isSelected ? 4 : 2.5) / this.transform.k;
                ctx.lineCap = 'round';
                ctx.shadowBlur = isHovered ? 5 : 0;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.stroke();
                
                if (!isSelected) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                    ctx.lineWidth = 1 / this.transform.k;
                    ctx.stroke();
                }
                ctx.globalCompositeOperation = 'source-over';
                ctx.shadowBlur = 0;
            }

            drawCity(ent, isHovered, isSelected) {
                const ctx = this.ctx;
                const pt = ent.currentGeometry[0];
                if (!pt) return;

                const size = 6 / this.transform.k;
                
                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y - size);
                ctx.lineTo(pt.x + size, pt.y);
                ctx.lineTo(pt.x, pt.y + size);
                ctx.lineTo(pt.x - size, pt.y);
                ctx.closePath();

                ctx.fillStyle = isSelected ? '#8a3324' : ent.color;
                ctx.fill();
                
                if (isSelected || isHovered) {
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, size * 1.5, 0, Math.PI*2);
                    ctx.strokeStyle = '#8a3324';
                    ctx.lineWidth = 1 / this.transform.k;
                    ctx.stroke();
                }

                ctx.fillStyle = '#2b2118';
                ctx.font = `bold ${12}px "Cinzel"`;
                ctx.textAlign = 'left';
                ctx.fillText(ent.name, pt.x + size * 1.5, pt.y + size/2);
            }

            getJitter(seed) {
                const amount = CONFIG.WATERCOLOR_JITTER / this.transform.k;
                return {
                    x: (Math.random() - 0.5) * amount * (seed + 1),
                    y: (Math.random() - 0.5) * amount * (seed + 1)
                };
            }

            drawLabel(ent, isSelected) {
                let sx=0, sy=0;
                ent.currentGeometry.forEach(p => { sx+=p.x; sy+=p.y; });
                const cx = sx/ent.currentGeometry.length;
                const cy = sy/ent.currentGeometry.length;
                this.ctx.fillStyle = isSelected ? '#fff' : '#8a3324';
                if(isSelected) this.ctx.shadowBlur = 4;
                this.ctx.font = '14px "Cinzel"';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(ent.name, cx, cy);
                this.ctx.shadowBlur = 0;
            }

            drawDraft(points, cursor, transform, type) {
                if (!points || points.length === 0) return;
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(transform.x, transform.y);
                ctx.scale(transform.k, transform.k);
                
                points.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 3/transform.k, 0, Math.PI*2);
                    ctx.fillStyle='#8a3324'; ctx.fill();
                });

                if (type === 'city') {
                    const p = points[0];
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y - 5); ctx.lineTo(p.x + 5, p.y);
                    ctx.lineTo(p.x, p.y + 5); ctx.lineTo(p.x - 5, p.y);
                    ctx.fillStyle = '#8a3324'; ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                    if(cursor) ctx.lineTo(cursor.x, cursor.y);
                    ctx.strokeStyle = '#8a3324';
                    ctx.lineWidth = 2/transform.k;
                    ctx.setLineDash([5/transform.k, 5/transform.k]);
                    ctx.stroke();
                }
                ctx.restore();
            }

            tracePath(pts, close) {
                if(!pts.length) return;
                this.ctx.moveTo(pts[0].x, pts[0].y);
                for(let i=1; i<pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);
                if(close) this.ctx.closePath();
            }

            drawGrid() {
                const ctx = this.ctx;
                const sz = 100; const cnt = 30;
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(138, 51, 36, 0.05)';
                ctx.lineWidth = 1/this.transform.k;
                for(let i=-cnt; i<=cnt; i++) {
                    ctx.moveTo(i*sz, -cnt*sz); ctx.lineTo(i*sz, cnt*sz);
                    ctx.moveTo(-cnt*sz, i*sz); ctx.lineTo(cnt*sz, i*sz);
                }
                ctx.stroke();
            }

            hexToRgba(hex, a) {
                const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
                return `rgba(${r},${g},${b},${a})`;
            }
        }

        // --- 4. Input & Interaction ---
        class InputController {
            constructor(app) {
                this.app = app;
                this.renderer = app.renderer;
                this.isDragging = false;
                this.lastX=0; this.lastY=0; this.hoverThrottle=0;
                this.init();
            }

            init() {
                const c = this.renderer.canvas;
                c.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const d = -Math.sign(e.deltaY);
                    const s = 1 + (d*0.1);
                    const t = this.renderer.transform;
                    const mx = e.offsetX, my = e.offsetY;
                    const wp = this.renderer.toWorld(mx, my);
                    t.k = Math.max(CONFIG.MIN_ZOOM, Math.min(CONFIG.MAX_ZOOM, t.k * s));
                    t.x = mx - (wp.x * t.k);
                    t.y = my - (wp.y * t.k);
                    this.app.render();
                });

                c.addEventListener('mousedown', (e) => {
                    if (this.app.activeTool === 'pan') {
                        this.isDragging = true;
                        this.lastX = e.clientX; this.lastY = e.clientY;
                        c.style.cursor = 'grabbing';
                    } else if (this.app.activeTool === 'inspect' && this.app.hoveredEntityId) {
                        this.app.selectEntity(this.app.hoveredEntityId);
                    } else if (this.app.activeTool === 'draw') {
                        const wp = this.renderer.toWorld(e.offsetX, e.offsetY);
                        if (this.app.drawType === 'city') {
                            this.app.addDraftPoint(wp);
                            this.app.commitDraft();
                        } else {
                            this.app.addDraftPoint(wp);
                        }
                    } else if (this.app.activeTool === 'erase' && this.app.hoveredEntityId) {
                        this.app.deleteEntity(this.app.hoveredEntityId);
                    }
                    if (this.app.activeTool !== 'inspect' && this.app.activeTool !== 'draw') this.app.deselect();
                });

                window.addEventListener('mousemove', (e) => {
                    if (this.isDragging && this.app.activeTool === 'pan') {
                        const dx = e.clientX - this.lastX;
                        const dy = e.clientY - this.lastY;
                        this.lastX = e.clientX; this.lastY = e.clientY;
                        this.renderer.transform.x += dx;
                        this.renderer.transform.y += dy;
                        this.app.render();
                        return;
                    }
                    const wp = this.renderer.toWorld(e.offsetX, e.offsetY);
                    if (this.app.activeTool === 'draw') { this.app.updateDraftCursor(wp); return; }
                    if (this.app.activeTool === 'inspect' || this.app.activeTool === 'erase') {
                        const now = Date.now();
                        if (now - this.hoverThrottle > 30) {
                            this.hoverThrottle = now;
                            this.app.checkHover(wp);
                        }
                    }
                });

                window.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    if(this.app.activeTool === 'pan') c.style.cursor = 'grab';
                });

                c.addEventListener('dblclick', (e) => {
                    if (this.app.activeTool === 'draw' && this.app.drawType !== 'city') {
                        e.preventDefault();
                        this.app.commitDraft();
                    }
                });

                window.addEventListener('keydown', (e) => {
                    if (this.app.activeTool === 'draw') {
                        if (e.key === 'Enter') this.app.commitDraft();
                        if (e.key === 'Escape') this.app.cancelDraft();
                    }
                });
            }
        }

        // --- 5. App Logic ---
        class IlluminarchismApp {
            constructor() {
                this.renderer = new MedievalRenderer('map-canvas');
                this.input = new InputController(this);
                this.entities = [];
                this.hoveredEntityId = null;
                this.selectedEntityId = null;
                this.currentYear = 1000;
                this.draftPoints = [];
                this.draftCursor = null;
                this.activeTool = 'pan';
                this.drawType = 'polity';
                
                // New State
                this.isPlaying = false;
                this.playInterval = null;
                this.layerVisibility = { polity: true, river: true, city: true };

                this.initData();
                this.initUI();
                this.updateEntities();
                this.render();
            }

            initData() {
                const blue = new HistoricalEntity('blue_kg', 'Regnum Caeruleum', 'polity', '#264e86');
                blue.addKeyframe(800, [{x:-100,y:-100}, {x:100,y:-100}, {x:100,y:100}, {x:-100,y:100}]);
                blue.addKeyframe(1200, [{x:-200,y:-150}, {x:250,y:-120}, {x:200,y:200}, {x:-180,y:180}]);
                this.entities.push(blue);

                const river = new HistoricalEntity('river_alpha', 'Fluvius Magnus', 'river', '#43b3ae');
                river.addKeyframe(800, [{x:-300, y:-200}, {x:-150, y:-50}, {x:0, y:0}, {x:150, y:50}, {x:300, y:200}]);
                this.entities.push(river);
                
                const city = new HistoricalEntity('city_capital', 'Urbs Aeterna', 'city', '#000000');
                city.addKeyframe(800, [{x:0, y:0}]);
                this.entities.push(city);
            }

            initUI() {
                const slider = document.getElementById('time-slider');
                const display = document.getElementById('year-display');
                
                slider.addEventListener('input', (e) => {
                    this.currentYear = parseInt(e.target.value);
                    display.textContent = `${this.currentYear} AD`;
                    this.updateEntities();
                    this.render();
                });

                // Play Button Logic
                const playBtn = document.getElementById('btn-play');
                playBtn.addEventListener('click', () => this.togglePlay(playBtn, slider, display));

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool-btn').forEach(t => t.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        this.setTool(e.currentTarget.dataset.tool);
                    });
                });

                const typeSelect = document.getElementById('draw-type-select');
                typeSelect.addEventListener('change', (e) => {
                    this.drawType = e.target.value;
                    if(this.activeTool === 'draw') this.setTool('draw');
                });

                // Layer Toggles
                document.getElementById('layer-polity').addEventListener('change', (e) => { this.layerVisibility.polity = e.target.checked; this.render(); });
                document.getElementById('layer-river').addEventListener('change', (e) => { this.layerVisibility.river = e.target.checked; this.render(); });
                document.getElementById('layer-city').addEventListener('change', (e) => { this.layerVisibility.city = e.target.checked; this.render(); });

                document.getElementById('btn-deselect').addEventListener('click', () => this.deselect());
                document.getElementById('btn-update-meta').addEventListener('click', () => this.updateSelectedMetadata());

                document.getElementById('btn-save').addEventListener('click', () => this.saveAtlas());
                const fileInput = document.getElementById('file-input');
                document.getElementById('btn-load').addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.loadAtlas(e));
            }

            togglePlay(btn, slider, display) {
                if (this.isPlaying) {
                    this.isPlaying = false;
                    clearInterval(this.playInterval);
                    btn.textContent = '‚ñ∂';
                } else {
                    this.isPlaying = true;
                    btn.textContent = '‚è∏';
                    this.playInterval = setInterval(() => {
                        let y = parseInt(slider.value) + 2; // Speed: 2 years per tick
                        if (y > parseInt(slider.max)) y = parseInt(slider.min);
                        slider.value = y;
                        this.currentYear = y;
                        display.textContent = `${y} AD`;
                        this.updateEntities();
                        this.render();
                    }, 50);
                }
            }

            saveAtlas() {
                const data = JSON.stringify(this.entities, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = `atlas_backup_${new Date().toISOString().slice(0,10)}.atlas`;
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            loadAtlas(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const rawData = JSON.parse(e.target.result);
                        this.entities = rawData.map(obj => HistoricalEntity.fromJSON(obj));
                        this.updateEntities();
                        this.render();
                        alert('Atlas loaded successfully.');
                    } catch (err) { console.error(err); alert('Failed to parse atlas file.'); }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            setTool(name) {
                this.activeTool = name;
                this.cancelDraft();
                
                const hint = document.getElementById('draw-hint');
                if (name === 'draw') {
                    hint.classList.add('visible');
                    if (this.selectedEntityId) {
                        const ent = this.entities.find(e => e.id === this.selectedEntityId);
                        hint.textContent = `EDITING: ${ent.name}. Redraw geometry for ${this.currentYear}.`;
                        this.drawType = ent.type;
                        document.getElementById('draw-type-select').value = ent.type;
                    } else {
                        if (this.drawType === 'city') hint.textContent = "Click once to place City.";
                        else hint.textContent = `Click to draw ${this.drawType}. Double-click to finish.`;
                    }
                } else {
                    hint.classList.remove('visible');
                }

                const c = this.renderer.canvas;
                c.style.cursor = 'default';
                if(name==='pan') c.style.cursor='grab';
                else if(name==='draw') c.style.cursor='crosshair';
                else if(name==='erase') c.style.cursor='not-allowed';
                
                this.render();
            }

            addDraftPoint(p) {
                const last = this.draftPoints[this.draftPoints.length - 1];
                if (last && Math.abs(last.x - p.x) < 2 && Math.abs(last.y - p.y) < 2) return;
                this.draftPoints.push(p);
                this.render();
            }

            updateDraftCursor(p) { this.draftCursor = p; this.render(); }

            commitDraft() {
                if (this.draftPoints.length === 0) return;
                if (this.drawType !== 'city' && this.draftPoints.length < 2) return;

                if (this.selectedEntityId) {
                    const ent = this.entities.find(e => e.id === this.selectedEntityId);
                    if (ent) {
                        ent.addKeyframe(this.currentYear, [...this.draftPoints]);
                        this.updateInfoPanel(ent);
                    }
                } else {
                    const id = 'ent_' + Date.now();
                    const colors = ['#8a3324', '#264e86', '#c5a059', '#3a5f3a', '#5c3c92'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    let name = "New Territory";
                    if (this.drawType === 'city') name = "New Settlement";
                    if (this.drawType === 'river') name = "New River";

                    const newEnt = new HistoricalEntity(id, name, this.drawType, color);
                    newEnt.addKeyframe(this.currentYear, [...this.draftPoints]);
                    newEnt.validRange.start = this.currentYear - 200;
                    newEnt.validRange.end = this.currentYear + 200;
                    
                    this.entities.push(newEnt);
                    this.selectEntity(id);
                }

                this.draftPoints = [];
                this.draftCursor = null;
                this.updateEntities();
                this.render();
                if(this.activeTool === 'draw') this.setTool('draw');
            }

            cancelDraft() { this.draftPoints=[]; this.draftCursor=null; this.render(); }

            deleteEntity(id) {
                this.entities = this.entities.filter(e => e.id !== id);
                if(this.selectedEntityId === id) this.deselect();
                this.hoveredEntityId = null;
                this.updateEntities();
                this.render();
            }

            deselect() {
                this.selectedEntityId = null;
                document.getElementById('info-panel').style.display = 'none';
                if (this.activeTool === 'draw') this.setTool('draw');
                this.render();
            }

            selectEntity(id) {
                this.selectedEntityId = id;
                const ent = this.entities.find(e => e.id === id);
                if (ent) {
                    const p = document.getElementById('info-panel');
                    p.style.display = 'block';
                    document.getElementById('info-name-input').value = ent.name;
                    document.getElementById('info-type').textContent = ent.type;
                    document.getElementById('info-color-input').value = ent.color; // Set picker
                    document.getElementById('info-span').textContent = `${ent.validRange.start} - ${ent.validRange.end}`;
                    this.updateInfoPanel(ent);
                    if (this.activeTool === 'draw') this.setTool('draw');
                }
                this.render();
            }

            updateSelectedMetadata() {
                if (!this.selectedEntityId) return;
                const ent = this.entities.find(e => e.id === this.selectedEntityId);
                if (ent) {
                    ent.name = document.getElementById('info-name-input').value;
                    ent.color = document.getElementById('info-color-input').value;
                    this.render();
                }
            }

            updateInfoPanel(ent) {
                const list = document.getElementById('keyframe-list');
                list.innerHTML = '';
                ent.timeline.forEach(kf => {
                    const div = document.createElement('div');
                    div.textContent = `‚Ä¢ ${kf.year} AD`;
                    div.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
                    list.appendChild(div);
                });
            }

            checkHover(wp) {
                if (this.activeTool !== 'inspect' && this.activeTool !== 'erase') return;
                let fid = null;
                
                // Filter by visible layers only
                const visibleEntities = this.entities.filter(e => this.layerVisibility[e.type]);

                // Check cities first
                for (let i = visibleEntities.length - 1; i >= 0; i--) {
                    const e = visibleEntities[i];
                    if (!e.currentGeometry || e.type !== 'city') continue;
                    if (distance(wp, e.currentGeometry[0]) < 10/this.renderer.transform.k) { fid = e.id; break; }
                }

                // Check polygons
                if (!fid) {
                    for (let i = visibleEntities.length - 1; i >= 0; i--) {
                        const e = visibleEntities[i];
                        if (!e.currentGeometry || e.type !== 'polity') continue;
                        if (isPointInPolygon(wp, e.currentGeometry)) { fid = e.id; break; }
                    }
                }
                
                // Check rivers
                if (!fid) {
                     for (let i = visibleEntities.length - 1; i >= 0; i--) {
                        const e = visibleEntities[i];
                        if (!e.currentGeometry || e.type !== 'river') continue;
                        const pts = e.currentGeometry;
                        for(let j=0; j<pts.length-1; j++) {
                            if(distanceToSegment(wp, pts[j], pts[j+1]) < 5/this.renderer.transform.k) { fid = e.id; break; }
                        }
                        if(fid) break;
                    }
                }

                if (fid !== this.hoveredEntityId) {
                    this.hoveredEntityId = fid;
                    this.renderer.canvas.style.cursor = (this.activeTool==='erase') ? (fid?'pointer':'not-allowed') : (fid?'pointer':'default');
                    this.render();
                }
            }

            updateEntities() {
                let cnt = 0;
                this.entities.forEach(ent => {
                    ent.currentGeometry = ent.getGeometryAtYear(this.currentYear);
                    if (ent.currentGeometry) cnt++;
                });
                const d = document.querySelector('.debug-info');
                if(d) d.textContent = `Year: ${this.currentYear} | Active: ${cnt}`;
            }

            render() {
                this.renderer.draw(this.entities, this.hoveredEntityId, this.selectedEntityId, this.activeTool, this.layerVisibility);
                if (this.activeTool === 'draw' && this.draftPoints.length > 0) {
                    this.renderer.drawDraft(this.draftPoints, this.draftCursor, this.renderer.transform, this.drawType);
                }
            }
        }

        window.onload = () => { window.illuminarchismApp = new IlluminarchismApp(); };
    </script>
</body>
</html>
